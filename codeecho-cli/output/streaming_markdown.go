package output

import (
	"bufio"
	"fmt"
	"io"
	"strings"

	"github.com/opskraken/codeecho-cli/config"
	"github.com/opskraken/codeecho-cli/scanner"
	"github.com/opskraken/codeecho-cli/utils"
)

type StreamingMarkdownWriter struct {
	writer *bufio.Writer
	opts   config.OutputOptions
	stats  *scanner.StreamingStats
}

func NewStreamingMarkdownWriter(w io.Writer, opts config.OutputOptions) *StreamingMarkdownWriter {
	return &StreamingMarkdownWriter{
		writer: bufio.NewWriterSize(w, 65536),
		opts:   opts,
		stats: &scanner.StreamingStats{
			LanguageCounts: make(map[string]int),
		},
	}
}

func (w *StreamingMarkdownWriter) WriteHeader(repoPath string, scanTime string) error {
	header := fmt.Sprintf(`# CodeEcho Repository Scan

**Repository:** %s
**Scan Time:** %s

## Files

`, repoPath, scanTime)

	if _, err := w.writer.WriteString(header); err != nil {
		return err
	}

	return nil
}

func (w *StreamingMarkdownWriter) WriteTree(paths []string) error {
	if !w.opts.IncludeDirectoryTree || len(paths) == 0 {
		return nil
	}

	// Convert paths to FileInfo structs (minimal data needed for tree)
	fileInfos := make([]scanner.FileInfo, len(paths))
	for i, path := range paths {
		fileInfos[i] = scanner.FileInfo{RelativePath: path}
	}

	tree := GenerateDirectoryTree(fileInfos)

	// Write tree section
	if _, err := w.writer.WriteString("## Directory Structure\n\n"); err != nil {
		return err
	}
	if _, err := w.writer.WriteString("```\n"); err != nil {
		return err
	}
	if _, err := w.writer.WriteString(tree); err != nil {
		return err
	}
	if _, err := w.writer.WriteString("```\n\n"); err != nil {
		return err
	}

	return nil
}

func (w *StreamingMarkdownWriter) WriteFile(file *scanner.FileInfo) error {
	// Update stats
	w.stats.TotalFiles++
	w.stats.TotalSize += file.Size

	if file.IsText {
		w.stats.TextFiles++
	} else {
		w.stats.BinaryFiles++
	}

	if file.Language != "" {
		w.stats.LanguageCounts[file.Language]++
	}

	// File header
	if _, err := w.writer.WriteString(fmt.Sprintf("### %s\n\n", file.RelativePath)); err != nil {
		return err
	}

	// Metadata
	metadata := fmt.Sprintf("**Size:** %s", file.SizeFormatted)
	if file.Language != "" {
		metadata += fmt.Sprintf(" | **Language:** %s", file.Language)
	}
	if file.LineCount > 0 {
		metadata += fmt.Sprintf(" | **Lines:** %d", file.LineCount)
	}
	if file.Extension != "" {
		metadata += fmt.Sprintf(" | **Extension:** %s", file.Extension)
	}
	metadata += fmt.Sprintf(" | **Modified:** %s", file.ModTimeFormatted)
	metadata += fmt.Sprintf(" | **Text File:** %t\n\n", file.IsText)

	if _, err := w.writer.WriteString(metadata); err != nil {
		return err
	}

	// Content
	if w.opts.IncludeContent && file.Content != "" && file.IsText {
		codeBlock := fmt.Sprintf("```%s\n%s\n```\n\n", strings.ToLower(file.Language), file.Content)
		if _, err := w.writer.WriteString(codeBlock); err != nil {
			return err
		}
	} else if !file.IsText {
		if _, err := w.writer.WriteString("*Binary file - content not displayed*\n\n"); err != nil {
			return err
		}
	} else {
		if _, err := w.writer.WriteString("*Content not included*\n\n"); err != nil {
			return err
		}
	}

	// Separator
	if _, err := w.writer.WriteString("---\n\n"); err != nil {
		return err
	}

	return nil
}

func (w *StreamingMarkdownWriter) WriteFooter(stats *scanner.StreamingStats) error {
	footer := fmt.Sprintf(`## Scan Statistics

- **Total Files:** %d
- **Total Size:** %s
- **Text Files:** %d
- **Binary Files:** %d

---

*Generated by CodeEcho CLI*
`, stats.TotalFiles, utils.FormatBytes(stats.TotalSize), stats.TextFiles, stats.BinaryFiles)

	if _, err := w.writer.WriteString(footer); err != nil {
		return err
	}

	return nil
}

func (w *StreamingMarkdownWriter) Close() error {
	return w.writer.Flush()
}
