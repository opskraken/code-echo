package output

import (
	"bufio"
	"fmt"
	"io"
	"strings"

	"github.com/opskraken/codeecho-cli/config"
	"github.com/opskraken/codeecho-cli/scanner"
	"github.com/opskraken/codeecho-cli/utils"
)

// StreamingXMLWriter writes XML output incrementally
type StreamingXMLWriter struct {
	writer *bufio.Writer // Buffered writer for performance (batches small writes)
	opts   config.OutputOptions
	stats  *scanner.StreamingStats // Track stats as we go
}

// NewStreamingXMLWriter creates a new streaming XML writer
func NewStreamingXMLWriter(w io.Writer, opts config.OutputOptions) *StreamingXMLWriter {
	return &StreamingXMLWriter{
		writer: bufio.NewWriterSize(w, 65536), // 64KB buffer for efficiency
		opts:   opts,
		stats: &scanner.StreamingStats{
			LanguageCounts: make(map[string]int),
		},
	}
}

// WriteHeader writes the XML declaration and opening tags
func (w *StreamingXMLWriter) WriteHeader(repoPath string, scanTime string) error {
	// XML declaration
	if _, err := w.writer.WriteString(`<?xml version="1.0" encoding="UTF-8"?>` + "\n"); err != nil {
		return err
	}

	// Comments explaining processing
	if _, err := w.writer.WriteString("<!-- This file is a merged representation of the entire codebase, combined into a single document by CodeEcho CLI. -->\n"); err != nil {
		return err
	}

	if _, err := w.writer.WriteString("<!-- The content has been processed with the following options: "); err != nil {
		return err
	}

	var options []string
	if w.opts.RemoveComments {
		options = append(options, "comments removed")
	}
	if w.opts.RemoveEmptyLines {
		options = append(options, "empty lines removed")
	}
	if w.opts.CompressCode {
		options = append(options, "code compressed")
	}

	if len(options) > 0 {
		if _, err := w.writer.WriteString(strings.Join(options, ", ")); err != nil {
			return err
		}
	} else {
		if _, err := w.writer.WriteString("no processing applied"); err != nil {
			return err
		}
	}
	if _, err := w.writer.WriteString(" -->\n\n"); err != nil {
		return err
	}

	// File summary section
	if w.opts.IncludeSummary {
		summary := `<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure (if enabled)
4. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and CodeEcho's configuration
- Binary files are not included in this packed representation
- Files matching default ignore patterns are excluded
`
		if _, err := w.writer.WriteString(summary); err != nil {
			return err
		}

		if w.opts.RemoveComments || w.opts.RemoveEmptyLines || w.opts.CompressCode {
			if _, err := w.writer.WriteString("- File processing has been applied - content may differ from original files\n"); err != nil {
				return err
			}
		}

		if _, err := w.writer.WriteString(fmt.Sprintf("- Generated by CodeEcho CLI on %s\n", scanTime)); err != nil {
			return err
		}
		if _, err := w.writer.WriteString("</notes>\n\n</file_summary>\n\n"); err != nil {
			return err
		}
	}

	// Repository info (will update stats in footer)
	if _, err := w.writer.WriteString(fmt.Sprintf("<repository_info>\n<repo_path>%s</repo_path>\n<scan_time>%s</scan_time>\n</repository_info>\n\n", escapeXML(repoPath), scanTime)); err != nil {
		return err
	}

	// Start files section
	if _, err := w.writer.WriteString("<files>\nThis section contains the contents of the repository's files.\n\n"); err != nil {
		return err
	}

	return nil
}

func (w *StreamingXMLWriter) WriteTree(paths []string) error {
	if !w.opts.IncludeDirectoryTree || len(paths) == 0 {
		return nil
	}

	// Convert paths to FileInfo structs (minimal data)
	fileInfos := make([]scanner.FileInfo, len(paths))
	for i, path := range paths {
		fileInfos[i] = scanner.FileInfo{RelativePath: path}
	}

	tree := GenerateDirectoryTree(fileInfos)

	if _, err := w.writer.WriteString("<directory_structure>\n"); err != nil {
		return err
	}
	if _, err := w.writer.WriteString(tree); err != nil {
		return err
	}
	if _, err := w.writer.WriteString("</directory_structure>\n\n"); err != nil {
		return err
	}

	return nil
}

// WriteFile writes a single file entry
// This is called once per file - the key to streaming!
func (w *StreamingXMLWriter) WriteFile(file *scanner.FileInfo) error {
	// Update statistics as we go
	w.stats.TotalFiles++
	w.stats.TotalSize += file.Size

	if file.IsText {
		w.stats.TextFiles++
	} else {
		w.stats.BinaryFiles++
	}

	if file.Language != "" {
		w.stats.LanguageCounts[file.Language]++
	}

	// Write file opening tag with attributes
	if _, err := w.writer.WriteString(fmt.Sprintf(`<file path="%s"`, escapeXML(file.RelativePath))); err != nil {
		return err
	}

	if file.Language != "" {
		if _, err := w.writer.WriteString(fmt.Sprintf(` language="%s"`, file.Language)); err != nil {
			return err
		}
	}

	if file.LineCount > 0 {
		if _, err := w.writer.WriteString(fmt.Sprintf(` lines="%d"`, file.LineCount)); err != nil {
			return err
		}
	}

	if _, err := w.writer.WriteString(fmt.Sprintf(` size="%s"`, file.SizeFormatted)); err != nil {
		return err
	}

	if file.Extension != "" {
		if _, err := w.writer.WriteString(fmt.Sprintf(` extension="%s"`, file.Extension)); err != nil {
			return err
		}
	}

	if _, err := w.writer.WriteString(fmt.Sprintf(` modified="%s"`, file.ModTimeFormatted)); err != nil {
		return err
	}

	if _, err := w.writer.WriteString(fmt.Sprintf(` is_text="%t"`, file.IsText)); err != nil {
		return err
	}

	if _, err := w.writer.WriteString(">\n"); err != nil {
		return err
	}

	// Write content
	if w.opts.IncludeContent && file.Content != "" && file.IsText {
		if w.opts.ShowLineNumbers {
			numbered := addLineNumbers(file.Content)
			if _, err := w.writer.WriteString(numbered); err != nil {
				return err
			}
		} else {
			escaped := escapeXML(file.Content)
			if _, err := w.writer.WriteString(escaped); err != nil {
				return err
			}
		}
	} else if !file.IsText {
		if _, err := w.writer.WriteString("<!-- Binary file - content not included -->"); err != nil {
			return err
		}
	} else {
		if _, err := w.writer.WriteString("<!-- Content not included -->"); err != nil {
			return err
		}
	}

	// Close file tag
	if _, err := w.writer.WriteString("\n</file>\n\n"); err != nil {
		return err
	}

	return nil
}

// WriteFooter writes closing tags and final statistics
func (w *StreamingXMLWriter) WriteFooter(stats *scanner.StreamingStats) error {
	// Close files section
	if _, err := w.writer.WriteString("</files>\n\n"); err != nil {
		return err
	}

	// Write final statistics section
	statsXML := fmt.Sprintf(`<scan_statistics>
<total_files>%d</total_files>
<total_size>%s</total_size>
<text_files>%d</text_files>
<binary_files>%d</binary_files>
</scan_statistics>
`, stats.TotalFiles, utils.FormatBytes(stats.TotalSize), stats.TextFiles, stats.BinaryFiles)

	if _, err := w.writer.WriteString(statsXML); err != nil {
		return err
	}

	return nil
}

// Close flushes the buffer and closes the writer
func (w *StreamingXMLWriter) Close() error {
	return w.writer.Flush() // Important: flush buffered data to disk
}

// Helper functions for XML processing
func escapeXML(s string) string {
	s = strings.ReplaceAll(s, "&", "&amp;")
	s = strings.ReplaceAll(s, "<", "&lt;")
	s = strings.ReplaceAll(s, ">", "&gt;")
	s = strings.ReplaceAll(s, `"`, "&quot;")
	s = strings.ReplaceAll(s, `'`, "&#39;")
	return s
}

func addLineNumbers(content string) string {
	lines := strings.Split(content, "\n")
	var numberedLines []string

	for i, line := range lines {
		numberedLines = append(numberedLines, fmt.Sprintf("%4d: %s", i+1, line))
	}

	return strings.Join(numberedLines, "\n")
}
