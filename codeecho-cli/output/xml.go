package output

import (
	"fmt"
	"strings"

	"github.com/opskraken/codeecho-cli/config"
	"github.com/opskraken/codeecho-cli/scanner"
	"github.com/opskraken/codeecho-cli/utils"
)

func GenerateXMLOutput(result *scanner.ScanResult, opts config.OutputOptions) (string, error) {
	var builder strings.Builder

	// XML declaration and root element
	builder.WriteString(`<?xml version="1.0" encoding="UTF-8"?>`)
	builder.WriteString("\n")
	builder.WriteString("<!-- This file is a merged representation of the entire codebase, combined into a single document by CodeEcho CLI. -->\n")
	builder.WriteString("<!-- The content has been processed with the following options: ")

	var options []string
	if opts.RemoveComments {
		options = append(options, "comments removed")
	}
	if opts.RemoveEmptyLines {
		options = append(options, "empty lines removed")
	}
	if opts.CompressCode {
		options = append(options, "code compressed")
	}
	if len(options) > 0 {
		builder.WriteString(strings.Join(options, ", "))
	} else {
		builder.WriteString("no processing applied")
	}
	builder.WriteString(" -->\n\n")

	// File summary section
	if opts.IncludeSummary {
		builder.WriteString("<file_summary>\n")
		builder.WriteString("This section contains a summary of this file.\n\n")

		builder.WriteString("<purpose>\n")
		builder.WriteString("This file contains a packed representation of the entire repository's contents.\n")
		builder.WriteString("It is designed to be easily consumable by AI systems for analysis, code review,\n")
		builder.WriteString("or other automated processes.\n")
		builder.WriteString("</purpose>\n\n")

		builder.WriteString("<file_format>\n")
		builder.WriteString("The content is organized as follows:\n")
		builder.WriteString("1. This summary section\n")
		builder.WriteString("2. Repository information\n")
		if opts.IncludeDirectoryTree {
			builder.WriteString("3. Directory structure\n")
			builder.WriteString("4. Multiple file entries, each consisting of:\n")
		} else {
			builder.WriteString("3. Multiple file entries, each consisting of:\n")
		}
		builder.WriteString("  - File path as an attribute\n")
		builder.WriteString("  - Full contents of the file\n")
		builder.WriteString("</file_format>\n\n")

		builder.WriteString("<usage_guidelines>\n")
		builder.WriteString("- This file should be treated as read-only. Any changes should be made to the\n")
		builder.WriteString("  original repository files, not this packed version.\n")
		builder.WriteString("- When processing this file, use the file path to distinguish\n")
		builder.WriteString("  between different files in the repository.\n")
		builder.WriteString("- Be aware that this file may contain sensitive information. Handle it with\n")
		builder.WriteString("  the same level of security as you would the original repository.\n")
		builder.WriteString("</usage_guidelines>\n\n")

		builder.WriteString("<notes>\n")
		builder.WriteString("- Some files may have been excluded based on .gitignore rules and CodeEcho's configuration\n")
		builder.WriteString("- Binary files are not included in this packed representation\n")
		builder.WriteString("- Files matching default ignore patterns are excluded\n")
		if opts.RemoveComments || opts.RemoveEmptyLines || opts.CompressCode {
			builder.WriteString("- File processing has been applied - content may differ from original files\n")
		}
		builder.WriteString(fmt.Sprintf("- Generated by CodeEcho CLI on %s\n", result.ScanTime))
		builder.WriteString("</notes>\n\n")

		builder.WriteString("</file_summary>\n\n")
	}

	// Repository information
	builder.WriteString("<repository_info>\n")
	builder.WriteString(fmt.Sprintf("<repo_path>%s</repo_path>\n", escapeXML(result.RepoPath)))
	builder.WriteString(fmt.Sprintf("<scan_time>%s</scan_time>\n", result.ScanTime))
	builder.WriteString(fmt.Sprintf("<total_files>%d</total_files>\n", result.TotalFiles))
	builder.WriteString(fmt.Sprintf("<total_size>%s</total_size>\n", utils.FormatBytes(result.TotalSize)))
	builder.WriteString(fmt.Sprintf("<processed_by>%s</processed_by>\n", result.ProcessedBy))
	builder.WriteString("</repository_info>\n\n")

	// Directory structure
	if opts.IncludeDirectoryTree {
		builder.WriteString("<directory_structure>\n")
		builder.WriteString(GenerateDirectoryTree(result.Files))
		builder.WriteString("</directory_structure>\n\n")
	}

	// Files section
	builder.WriteString("<files>\n")
	builder.WriteString("This section contains the contents of the repository's files.\n\n")

	for _, file := range result.Files {
		builder.WriteString(fmt.Sprintf(`<file path="%s"`, escapeXML(file.RelativePath)))

		// Add metadata attributes
		if file.Language != "" {
			builder.WriteString(fmt.Sprintf(` language="%s"`, file.Language))
		}
		if file.LineCount > 0 {
			builder.WriteString(fmt.Sprintf(` lines="%d"`, file.LineCount))
		}
		builder.WriteString(fmt.Sprintf(` size="%s"`, file.SizeFormatted))

		if file.Extension != "" {
			builder.WriteString(fmt.Sprintf(` extension="%s"`, file.Extension))
		}

		builder.WriteString(fmt.Sprintf(` modified="%s"`, file.ModTimeFormatted))
		builder.WriteString(fmt.Sprintf(` is_text="%t"`, file.IsText))
		builder.WriteString(">\n")

		// Include content only for text files and if requested
		if opts.IncludeContent && file.Content != "" && file.IsText {
			if opts.ShowLineNumbers {
				builder.WriteString(addLineNumbers(file.Content))
			} else {
				builder.WriteString(escapeXML(file.Content))
			}
		} else if !file.IsText {
			builder.WriteString("<!-- Binary file - content not included -->")
		} else {
			builder.WriteString("<!-- Content not included -->")
		}

		builder.WriteString("\n</file>\n\n")
	}

	builder.WriteString("</files>\n")

	return builder.String(), nil
}


